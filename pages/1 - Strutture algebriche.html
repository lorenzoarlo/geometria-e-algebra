<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link rel="icon" href="../resources/logo.png" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <script defer id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script defer src="../scripts/TypewritingText.js"></script>
    <link rel="stylesheet" href="../styles/style.css" />
    <script src="../scripts/proof-event.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-78NHLXDQD8');
    </script>
    <title>1 - Strutture algebriche</title>
</head>

<body>
    <header class="header-container">
        <div class="logo-wrapper">
        </div>
        <div class="header-title">
            <h1>Geometria e algebra</h1>
            <span>1 - Strutture algebriche</span>
        </div>
        <div class="material-symbols-outlined header-title settings-button">
            <!-- settings -->
        </div>
    </header>
    <div class="main-container">
        <div class="content-container">
            <div class="section part" id="sec1" ><span class="section-header part-title">1 - Operazioni e strutture algebriche</span><div class="subsection part" id="subsec1-1" ><span class="subsection-header part-title">1.1 - Gruppi, anelli e campi</span><div class="definition environment" id="def1-1" ><span class="definition-header environment-title">Definizione 1.1 - Operazione interna su un insieme</span>     Si dice operazione interna su un insieme <span class="math-tag">\( A\)</span>, una qualsiasi funzione che sia definita da <span class="math-tag">\( A \times A\)</span> ad <span class="math-tag">\( A\)</span>, ovvero     <span class="math-tag">\[         A \times A \to A     \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Attenzione!</span>         Con "<span class="math-tag">\( A \times A \to A\)</span>" si indica che l'operazione è binaria (ovvero che è tra due elementi di <span class="math-tag">\( A\)</span>) e che restituisce un elemento di <span class="math-tag">\( A\)</span>.     </div></div><div class="definition environment" id="def1-2" ><span class="definition-header environment-title">Definizione 1.2 - Struttura algebrica</span>     Una struttura algebrica è un insieme caratterizzato da una o più operazioni. Genericamente si indica con     <span class="math-tag">\[         (A, *, *, \ \ldots \, *)     \]</span>     dove <span class="math-tag">\( A\)</span> è un insieme e <span class="math-tag">\( *\)</span> è una qualsiasi operazione in <span class="math-tag">\( A\)</span>. </div><div class="definition environment" id="def1-3" ><span class="definition-header environment-title">Definizione 1.3 - Gruppo</span>     Un gruppo è una struttura algebrica <span class="math-tag">\( (G, *)\)</span> dove <span class="math-tag">\( *\)</span> è un'operazione binaria su <span class="math-tag">\( G\)</span> tale che:     <ul ><li >l'operazione è associativa, ovvero considerando <span class="math-tag">\( a, b, c \in A\)</span> si ha che l         <span class="math-tag">\[             a * (b * c) = (a * b) * c         \]</span></li><li >esiste l'elemento neutro rispetto all'operazione <span class="math-tag">\( *\)</span> (indicato con <span class="math-tag">\( u_{A}\)</span>), ovvero considerando <span class="math-tag">\( a \in A\)</span><span class="math-tag">\[             \exists u_{A} \in A             \quad             :             \quad             u_{A} * a = a * u_{A} = a          \]</span></li><li >esiste l'inverso rispetto all'operazione <span class="math-tag">\( *\)</span> (indicato con <span class="math-tag">\( a^{-1}\)</span>), ovvero considerando <span class="math-tag">\( a \in A\)</span><span class="math-tag">\[             \exists a^{-1} \in A              \quad             :             \quad             a^{-1} * a = a * a^{-1} = u_{A}         \]</span></li></ul><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Esempi di gruppi</span>         Sono gruppi le strutture         <ul ><li ><span class="math-tag">\( (\mathbb{Z}, +)\)</span>, ovvero i numeri relativi e l'operazione della somma;             </li><li ><span class="math-tag">\( (\mathbb{Q}, +)\)</span>, ovvero i numeri razionali e l'operazione della somma;             </li><li ><span class="math-tag">\( (\mathbb{R}, +)\)</span>, ovvero i numeri reali e l'operazione della somma.         </li></ul>         &Egrave; necessario notare che <span class="math-tag">\( (\mathbb{N}, +)\)</span> non è un gruppo, in quanto non esiste l'elemento neutro rispetto alla somma (ovvero non esistono i numeri negativi).     </div></div><div class="myexample environment" id="example1" ><span class="myexample-header environment-title">Esempio 1 - Verificare che una struttura sia un gruppo</span>     La struttura algebrica <span class="math-tag">\( (\mathbb{Z}, *)\)</span> con <span class="math-tag">\( a * b = a + b - 3\)</span>, ovvero     <span class="math-tag">\[         (\mathbb{Z}, *)         \quad         :         \quad         a * b = a + b - 3     \]</span>     è un gruppo?     <br ></br>     Per verificare ciò è necessario verificare se     <ul ><li >l'operazione è associativa, ovvero se è valido         <span class="math-tag">\begin{aligned}             & a * (b * c) = (a * b) * c             & \iff \\             & a * (b + c - 3) = (a + b - 3) * c             & \iff \\             & a + (b + c - 3) - 3 = (a + b - 3) + c - 3             & \iff \\             & a + b + c - 6 = a + b + c - 6             &         \end{aligned}</span>         che verifica l'associatività;         </li><li >esiste un elemento neutro, ovvero se esiste un elemento <span class="math-tag">\( u_{\mathbb{Z}}\)</span><span class="math-tag">\begin{aligned}             & u_{\mathbb{Z}} * a = a * u_{\mathbb{Z}} = a             & \iff \\             & u_{\mathbb{Z}} + a - 3 = a + u_{\mathbb{Z}} - 3 = a             & \iff         \end{aligned}</span>         e aggiungendo <span class="math-tag">\( 3\)</span> in tutte le uguaglianze         <span class="math-tag">\begin{aligned}             & u_{\mathbb{Z}} + a = a + u_{\mathbb{Z}} = a + 3             & \iff         \end{aligned}</span>         e sottraendo <span class="math-tag">\( a\)</span> in tutte le uguaglianze         <span class="math-tag">\begin{aligned}             & u_{\mathbb{Z}} = u_{\mathbb{Z}} = 3             &         \end{aligned}</span>         si ottiene che tale elemento è <span class="math-tag">\( 3\)</span> che appartiene a <span class="math-tag">\( \mathbb{Z}\)</span>;         </li><li >esiste l'inverso, ovvero se esiste un elemento <span class="math-tag">\( a^{-1}\)</span><span class="math-tag">\begin{aligned}             & a^{-1} * a = a * a^{-1} = u_{\mathbb{Z}}             & \iff \\             & a^{-1} + a - 3 = a + a^{-1} - 3 = 3             & \iff         \end{aligned}</span>         e aggiungendo <span class="math-tag">\( 3\)</span> a tutte le uguaglianze e sottraendo <span class="math-tag">\( a\)</span> si ottiene         <span class="math-tag">\begin{aligned}             & a^{-1} = a^{-1} = 6 - a             &         \end{aligned}</span>         che verifica l'esistenza dell'inverso.     </li></ul>     Si è quindi dimostrato che tale struttura algebrica è un gruppo. </div><div class="definition environment" id="def1-4" ><span class="definition-header environment-title">Definizione 1.4 - Gruppo commutativo</span>     Un gruppo <span class="math-tag">\( (A, *)\)</span> si dice commutativo (o abeliano) se è valida la proprietà commutativa per ogni <span class="math-tag">\( a, b \in A\)</span>, ovvero     <span class="math-tag">\[         a * b = b * a     \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Esempi di gruppi commutativi</span>             Alcuni esempi di gruppi commutativi sono:             <ul ><li >il gruppo <span class="math-tag">\( (\mathbb{Z}, +)\)</span>,;                 </li><li >il gruppo <span class="math-tag">\( (\mathbb{Q}, +)\)</span>;                 </li><li >il gruppo <span class="math-tag">\( (\mathbb{R}, +)\)</span>;                 </li><li >il gruppo <span class="math-tag">\( (\mathbb{C}, +)\)</span>;                 </li><li >il gruppo <span class="math-tag">\( (\mathbb{R} \setminus \{ 0 \} , \cdot)\)</span> (in quanto <span class="math-tag">\( \mathbb{R}\)</span> con lo <span class="math-tag">\( 0\)</span> non permetterebbe l'esistenza di un inverso (nel caso dello <span class="math-tag">\( 0\)</span>).             </li></ul></div><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Gruppi che rappresentano la realtà non commutativi</span>         Bisogna notare che generalmente i gruppi che rappresentano la realtà non sono commutativi.      </div></div><div class="definition environment" id="def1-5" ><span class="definition-header environment-title">Definizione 1.5 - Anello</span>     Un anello è una struttura algebrica <span class="math-tag">\( (A, \oplus, *)\)</span> che rispetta le seguenti proprietà:     <ul ><li ><span class="math-tag">\( (A, \oplus)\)</span> è un gruppo commutativo;         </li><li >l'operazione <span class="math-tag">\( *\)</span> è associativa, ovvero considerando <span class="math-tag">\( a, b, c \in A\)</span><span class="math-tag">\[             a * (b * c) = (a * b) * c         \]</span></li><li >l'operazione <span class="math-tag">\( *\)</span> è distributiva rispetto a <span class="math-tag">\( \oplus\)</span>, ovvero considerando <span class="math-tag">\( a, b, c \in A\)</span><span class="math-tag">\[             a * (b \oplus c) = (a * b) \oplus (a * c)             \quad             \text{e}             \quad             (b \oplus c) * a = (b * a) \oplus (c * a)          \]</span></li></ul><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Sulla proprietà distributiva</span>         Dire che l'operazione <span class="math-tag">\( *\)</span> è distributiva rispetto all'operazione <span class="math-tag">\( \oplus\)</span> significa che "effettuare" l'operazione <span class="math-tag">\( *\)</span> sul risultato di un'operazione <span class="math-tag">\( \oplus\)</span> è uguale a "effettuare" l'operazione <span class="math-tag">\( *\)</span> separatamente e poi effettuare l'operazione <span class="math-tag">\( \oplus\)</span>.     </div><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Proprietà distributiva rispettata completamente</span>         &Egrave; necessario notare che la proprietà distributiva deve essere rispettata completamente: infatti, l'operazione <span class="math-tag">\( *\)</span> non richiede di essere commutativa, perciò <span class="math-tag">\( a * (b \oplus c)\)</span> e <span class="math-tag">\( (b \oplus c) * a\)</span> potrebbero essere due cose diverse.      </div></div><div class="definition environment" id="def1-6" ><span class="definition-header environment-title">Definizione 1.6 - Anello unitario</span>     Un anello si dice unitario (o con unità) se in <span class="math-tag">\( A\)</span> esiste un elemento neutro (l'unità) rispetto a <span class="math-tag">\( *\)</span>, ovvero considerando <span class="math-tag">\( a \in A\)</span><span class="math-tag">\[         \exists u \in A          \quad         :          \quad         a * u = u * u = a      \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Esempi di anelli unitari</span>         Un esempio di anello unitario è la struttura algebrica <span class="math-tag">\( (\mathbb{Z}, +, \cdot)\)</span> (dove <span class="math-tag">\( +\)</span> e <span class="math-tag">\( \cdot\)</span> sono le operazioni standard di somma e prodotto tra scalari) in quanto:         <ul ><li ><span class="math-tag">\( (\mathbb{Z}, +)\)</span> è un gruppo commutativo;             </li><li ><span class="math-tag">\( \cdot\)</span> è un'operazione associativa;             </li><li ><span class="math-tag">\( \cdot\)</span> è un'operazione distributiva rispetto alla somma;         </li></ul>         Un esempio di anello senza unità è <span class="math-tag">\( (P, +, \cdot)\)</span> dove <span class="math-tag">\( P\)</span> è l'insieme degli interi relativi pari: infatti <span class="math-tag">\( \cdot\)</span> non ha unità, in quanto <span class="math-tag">\( 1\)</span> non è pari.     </div></div><div class="definition environment" id="def1-7" ><span class="definition-header environment-title">Definizione 1.7 - Anello commutativo</span>     Un anello si dice commutativo se l'operazione <span class="math-tag">\( *\)</span> è commutativa, ovvero considerando <span class="math-tag">\( a, b \in A\)</span><span class="math-tag">\[         a * b = b * a     \]</span></div><div class="definition environment" id="def1-8" ><span class="definition-header environment-title">Definizione 1.8 - Divisori dello zero negli anelli</span>     In un anello <span class="math-tag">\( (A, +, *)\)</span> si dice che due elementi <span class="math-tag">\( a, b \in A\)</span> sono divisori dello zero se entrambi non sono nulli (ovvero <span class="math-tag">\( a \neq 0\)</span> e <span class="math-tag">\( b \neq 0\)</span>) ma         <span class="math-tag">\[         a * b = 0     \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Divisori dello zero e classi di modulo</span>         Negli insiemi numerici più comuni non esistono divisori dello zero. Sono tuttavia presenti negli insiemi delle classi di modulo (ad esempio <span class="math-tag">\( Z_{n} = \{ 0, 1, 2, \ \ldots \ , (n - 1) \}\)</span>) dove esistono in <span class="math-tag">\( Z_{n}\)</span> con <span class="math-tag">\( n\)</span> che non è un numero primo.     </div></div><div class="demonstration environment" id="dem1-1" ><span class="demonstration-header environment-title">Dimostrazione 1.1 - Elemento neutro di <span class="math-tag">\( +\)</span> come elemento nullo per <span class="math-tag">\( \cdot\)</span> in un anello</span>     Data la proprietà     <div class="proposition environment" ><span class="proposition-header environment-title">Enunciato</span>         Considerando un anello <span class="math-tag">\( (A, +, \cdot)\)</span> e <span class="math-tag">\( a \in A\)</span>, si ha che l'elemento neutro di <span class="math-tag">\( +\)</span> è l'elemento nullo dell'operazione <span class="math-tag">\( \cdot\)</span>, ovvero         <span class="math-tag">\[             a \cdot 0_{+} = 0_{+}         \]</span>         dove <span class="math-tag">\( 0_{+}\)</span> è l'elemento neutro dell'operazione <span class="math-tag">\( +\)</span>.     </div><div class="proof environment" ><span class="proof-header environment-title">Dimostrazione:<span class="material-symbols-outlined body-visibility-icon" onclick="set_proof_state(event)">visibility_off</span></span><div class="proof-body hyde">         Per dimostare tale proprietà consideriamo l'uguaglianza         <span class="math-tag">\begin{aligned}             & a \cdot 0 = a \cdot 0              & \iff         \end{aligned}</span>         Ricordando che <span class="math-tag">\( 0\)</span> è l'elemento neutro di <span class="math-tag">\( +\)</span> (ovvero <span class="math-tag">\( 0_{+}\)</span>), si può dire che         <span class="math-tag">\begin{aligned}             & a \cdot 0 = a \cdot (0 + 0)             & \iff         \end{aligned}</span>         e che <span class="math-tag">\( \cdot\)</span> è distributiva rispetto a <span class="math-tag">\( +\)</span>, possiamo scrivere         <span class="math-tag">\begin{aligned}             & a \cdot 0 = a \cdot 0 + a \cdot 0             & \iff         \end{aligned}</span>         Considerando quindi <span class="math-tag">\( b\)</span> l'opposto di <span class="math-tag">\( a \cdot 0\)</span> (ovvero l'elemento inverso rispetto a <span class="math-tag">\( +\)</span>), si ha quindi         <span class="math-tag">\begin{aligned}             & b + (a \cdot 0) = b + (a \cdot 0 + a \cdot 0)             & \iff         \end{aligned}</span>         e, annullando l'espressione a sinistra e applicando l'associatività di <span class="math-tag">\( +\)</span><span class="math-tag">\begin{aligned}             & 0 = (b + (a \cdot 0) + (a \cdot 0))             & \iff \\             & 0 = 0 + (a \cdot 0)              & \iff \\             & 0 = (a \cdot 0)         \end{aligned}</span>         che dimostra la proprietà.     </div></div><div class="proof environment" ><span class="proof-header environment-title">Dimostrazione:<span class="material-symbols-outlined body-visibility-icon" onclick="set_proof_state(event)">visibility_off</span></span><div class="proof-body hyde">         Considerando l'espressione          <span class="math-tag">\begin{aligned}             (1 + 0) \cdot a = (1 + 0) \cdot a          \end{aligned}</span>         (dove <span class="math-tag">\( 1\)</span> è l'elemento neutro di <span class="math-tag">\( \cdot\)</span> e <span class="math-tag">\( 0\)</span> è l'elemento neutro di <span class="math-tag">\( +\)</span>), è possibile svolgerla in due modi differenti.         <br ></br>         Concentrandosi sull'espressione a sinistra, si ha che, per la proprietà distributiva di <span class="math-tag">\( \cdot\)</span> rispetto a <span class="math-tag">\( +\)</span>, è possibile scrivere         <span class="math-tag">\begin{aligned}             & (1 \cdot a) + (0 \cdot a) = (1 + 0) \cdot a             & \iff         \end{aligned}</span>         e applicando la definizione di unità rispetto a <span class="math-tag">\( \cdot\)</span> si ha che         <span class="math-tag">\begin{aligned}             & a + (0 \cdot a) = (1 + 0) \cdot a             & \iff         \end{aligned}</span>         Concentrandosi ora sull'espressione a destra, si ha per le definizioni di unità         <span class="math-tag">\begin{aligned}             & a + (0 \cdot a) = 1 \cdot a             & \iff \\             & a + (0 \cdot a) = a             & \iff         \end{aligned}</span>         Dato che ogni elemento di un gruppo ammette inverso, si ha che è possibile aggiungere l'opposto di <span class="math-tag">\( a\)</span> (ovvero <span class="math-tag">\( b\)</span>, l'inverso di <span class="math-tag">\( a\)</span> rispetto a <span class="math-tag">\( +\)</span>) ad entrambe le espressioni         <span class="math-tag">\begin{aligned}             & b + a + (0 \cdot a) = b + a              & \iff         \end{aligned}</span>         e applicando la proprietà associativa a destra e risolvendo l'espressione a sinistra si ha che         <span class="math-tag">\begin{aligned}             & (b + a) + (0 \cdot a) = 0             & \iff         \end{aligned}</span>         Ricordando infine che <span class="math-tag">\( (b + a) = 0\)</span> è l'elemento neutro di <span class="math-tag">\( +\)</span>, si ha che         <span class="math-tag">\begin{aligned}             & 0 \cdot a = 0             &         \end{aligned}</span>         che dimostra la proprietà.     </div></div></div><div class="definition environment" id="def1-9" ><span class="definition-header environment-title">Definizione 1.9 - Campo</span>     Un campo è un anello commutativo unitario <span class="math-tag">\( (A, \oplus, *)\)</span> in cui ogni elemento non nullo ammette inverso rispetto a <span class="math-tag">\( *\)</span>, ovvero considerando <span class="math-tag">\( a \in A : a \neq 0_{A}\)</span><span class="math-tag">\[         \exists a^{-1} \in A          \quad         :         \quad         a * a^{-1} = u_{A}     \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Esempi di campi</span>         Esempi di campi sono le normali operazioni di somma e prodotto con:         <ul ><li >l'insieme dei numeri razionali (<span class="math-tag">\( (\mathbb{Q}, +, \cdot)\)</span>);             </li><li >l'insieme dei numeri reali (<span class="math-tag">\( (\mathbb{R}, +, \cdot)\)</span>);             </li><li >l'insieme dei numeri complessi (<span class="math-tag">\( (\mathbb{C}, +, \cdot)\)</span>);         </li></ul></div></div><div class="demonstration environment" id="dem1-2" ><span class="demonstration-header environment-title">Dimostrazione 1.2 - Campi senza divisori dello zero</span>     Data la proposizione     <div class="proposition environment" ><span class="proposition-header environment-title">Enunciato</span>         I campi non ammettono divisori dello zero.     </div><div class="proof environment" ><span class="proof-header environment-title">Dimostrazione:<span class="material-symbols-outlined body-visibility-icon" onclick="set_proof_state(event)">visibility_off</span></span><div class="proof-body hyde">         Per dimostrare tale proposizione, consideriamo il campo campo <span class="math-tag">\( (A, +, \cdot)\)</span>, <span class="math-tag">\( a, b \in A : a \neq 0\)</span> e <span class="math-tag">\( b \neq 0\)</span>, e supponiamo per assurdo che         <span class="math-tag">\begin{aligned}             & a \cdot b = 0             & \iff         \end{aligned}</span>         Dato che <span class="math-tag">\( a\)</span> non è nullo e siamo in un campo, <span class="math-tag">\( a\)</span> ammette inverso: si può quindi "moltiplicare" per <span class="math-tag">\( a^{-1}\)</span> da entrambe le parti         <span class="math-tag">\begin{aligned}             & a^{-1} \cdot (a \cdot b) = a^{-1} \cdot 0             & \iff         \end{aligned}</span>         Grazie all'associatività di <span class="math-tag">\( \cdot\)</span> è possibile scrivere         <span class="math-tag">\begin{aligned}             &(a^{-1} \cdot a) \cdot b = a^{-1} \cdot 0             & \iff         \end{aligned}</span>         e poi sostituire <span class="math-tag">\( (a^{-1} \cdot a)\)</span> con l'unità di <span class="math-tag">\( \cdot\)</span> (<span class="math-tag">\( 1\)</span>).         <span class="math-tag">\begin{aligned}             & 1 \cdot b = a^{-1} \cdot 0             & \iff \\             & b = a^{-1} \cdot 0             & \iff         \end{aligned}</span>         grazie al fatto che <span class="math-tag">\( 0\)</span> è l'elemento neutro di <span class="math-tag">\( +\)</span> (e quindi l'elemento nullo per <span class="math-tag">\( \cdot\)</span>)          <span class="math-tag">\begin{aligned}             & b = 0             &         \end{aligned}</span>         Si ottiene che <span class="math-tag">\( b = 0\)</span>, che è un assurdo in quanto <span class="math-tag">\( b \neq 0\)</span> era una delle assunzioni iniziali.     </div></div></div><div class="demonstration environment" id="dem1-3" ><span class="demonstration-header environment-title">Dimostrazione 1.3 - Condizione necessaria e sufficiente per gli insiemi delle classi di modulo per essere un campo</span>     Dato il teorema     <div class="proposition environment" ><span class="proposition-header environment-title">Enunciato</span><span class="math-tag">\( (\mathbb{Z}_{n}, +, \cdot)\)</span> è un campo se e solo se <span class="math-tag">\( n\)</span> è un numero primo.     </div><div class="proof environment" ><span class="proof-header environment-title">Dimostrazione:<span class="material-symbols-outlined body-visibility-icon" onclick="set_proof_state(event)">visibility_off</span></span><div class="proof-body hyde">         Per dimostrare tale teorema, è necessario dimostrare che         <ul ><li >"se <span class="math-tag">\( (\mathbb{Z}_{n}, +, \cdot)\)</span> è un campo, <span class="math-tag">\( n\)</span> è un numero primo". Per dimostrare ciò supponiamo per assurdo che <span class="math-tag">\( n\)</span> non sia primo. Ciò implicherebbe però che <span class="math-tag">\( \mathbb{Z}_{n}\)</span> ha divisori dello zero: dato che i campi non ammettono divisori dello zero, si è verificata questa implicazione.             </li><li >"se <span class="math-tag">\( n\)</span> è un numero primo, <span class="math-tag">\( (\mathbb{Z}_{n}, +, \cdot)\)</span> è un campo". Per dimostrare ciò è sufficiente dimostrare che ogni elemento non nullo ammette inverso rispetto a <span class="math-tag">\( \cdot\)</span>, in quanto le altre proprietà sono facilmente verificabili).             <br ></br>             Consideriamo quindi un elemento non nullo <span class="math-tag">\( z \in \mathbb{Z}_{n} : z \neq 0\)</span>. Dato che <span class="math-tag">\( \mathbb{Z}_{n}\)</span> ha finiti elementi, è possibile dire che potenze diverse avranno lo stesso valore, ovvero             <span class="math-tag">\begin{aligned}                 & z^{n} = z^{m} \qquad \text{con } n \gt m                 & \iff \\                 & z^{n} - z^{m} = 0                 & \iff             \end{aligned}</span>             Dato che la proprietà distributiva è valida negli anelli, è possibile "raccogliere" <span class="math-tag">\( z^{m}\)</span> e scrivere             <span class="math-tag">\begin{aligned}                 z^{m} \cdot (z^{n - m} - 1) = 0             \end{aligned}</span>             Dato che i campi non ammettono divisori dello zero, si ha che uno dei due fattori deve essere nullo. Dato che <span class="math-tag">\( z\)</span> non è nullo (per ipotesi iniziale), è impossibile che <span class="math-tag">\( z^{m}\)</span> lo sia, allora obbligatoriamente si ha che             <span class="math-tag">\begin{aligned}                 & z^{n - m} - 1 = 0                 & \iff \\                 & z^{n - m} = 1                 & \iff \\                 & z^{n - m - 1} \cdot z = 1                 &             \end{aligned}</span>             e ricordando che <span class="math-tag">\( 1\)</span> è l'elemento neutro di <span class="math-tag">\( \cdot\)</span>, si ha che ogni elemento non nullo ammette un inverso: <span class="math-tag">\( (\mathbb{Z}_{n}, +, \cdot)\)</span> è quindi un campo.         </li></ul>         Si è quindi dimostrato il teorema.     </div></div></div><div class="definition environment" id="def1-10" ><span class="definition-header environment-title">Definizione 1.10 - Campi di caratteristica <span class="math-tag">\( n\)</span></span>     Un campo si dice di caratteristica <span class="math-tag">\( n\)</span> se sommando l'unità <span class="math-tag">\( n\)</span> volte si ottiene l'elemento nullo e <span class="math-tag">\( n\)</span> è il più piccolo con questa proprietà.     <br ></br>     Se <span class="math-tag">\( n\)</span> non esiste, si dice che il campo è di caratteristica infinita.     <div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Campo di caratteristica <span class="math-tag">\( 2\)</span></span>         Il campo <span class="math-tag">\( (\mathbb{Z}_{2}, +, *)\)</span> è un campo di caratteristica <span class="math-tag">\( 2\)</span>.     </div></div></div><div class="subsection part" id="subsec1-2" ><span class="subsection-header part-title">1.2 - Omomorfismi e isomorfismi</span><div class="definition environment" id="def1-11" ><span class="definition-header environment-title">Definizione 1.11 - Omomorfismo di gruppi</span>     Considerando due gruppi <span class="math-tag">\( (A, +_{A})\)</span> e <span class="math-tag">\( (B, +_{B})\)</span>, la funzione     <span class="math-tag">\[         f: A \to B     \]</span>     è un omomorfismo se si ha che, considerando <span class="math-tag">\( a, b \in A\)</span><span class="math-tag">\[         f(a +_{A} b) = f(a) +_{B} f(b)     \]</span></div><div class="definition environment" id="def1-12" ><span class="definition-header environment-title">Definizione 1.12 - Funzione suriettiva</span>     Una funzione <span class="math-tag">\( f: X \to Y\)</span> si dice suriettiva (su <span class="math-tag">\( Y\)</span>) se      <span class="math-tag">\[         im(f) = Y,     \]</span>     ovvero se ogni elemento del codominio (<span class="math-tag">\( y \in Y\)</span>) è immagine di almeno un elemento del dominio (<span class="math-tag">\( x \in X\)</span>).     <div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Are you suriettiva?</span>         Per stabilire se una funzione è suriettiva si deve trattare <span class="math-tag">\( f(x) = y\)</span> come una vera è propria equazione e risolverla in favore di <span class="math-tag">\( x\)</span>.         <br ></br>         Una volta risolta, se la <span class="math-tag">\( x\)</span> trovata appartiene al dominio della funzione ed è valida per ogni <span class="math-tag">\( y\)</span>, si può dire che la funzione è suriettiva.     </div><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Interpretazione grafica</span>         Graficamente, una funzione è suriettiva se e solo se almeno una retta retta parallela all'asse <span class="math-tag">\( x\)</span> interseca il grafico della funzione in un suo punto almeno una volta.     </div></div><div class="myexample environment" id="example2" ><span class="myexample-header environment-title">Esempio 2 - Verificare se una funzione è suriettiva - Esempio 1</span>     Considerando la funzione     <span class="math-tag">\begin{aligned}         & f : \mathbb{R} \to \mathbb{R}         & f(x) = ax + b     \end{aligned}</span>     con <span class="math-tag">\( a \neq 0\)</span>, dimostriamo che sia suriettiva, ovvero che esiste almeno un elemento <span class="math-tag">\( x \in \mathbb{R}\)</span> per ogni <span class="math-tag">\( y \in \mathbb{R}\)</span>. Quindi     <span class="math-tag">\begin{aligned}         & f(x) = y         & \iff \\         & ax + b = y         & \iff \\         & x = \frac{y - b}{a}     \end{aligned}</span>     Possiamo dire che <span class="math-tag">\( f\)</span> è suriettiva su <span class="math-tag">\( Y\)</span> perchè ad ogni elemento <span class="math-tag">\( x\)</span> corrisponde almeno un elemento <span class="math-tag">\( y\)</span>. </div><div class="myexample environment" id="example3" ><span class="myexample-header environment-title">Esempio 3 - Verificare se una funzione è suriettiva - Esempio 2</span>     Considerando la funzione     <span class="math-tag">\begin{aligned}         & f : \mathbb{R} \to \mathbb{R}         & f(x) = x^{4}     \end{aligned}</span>     dimostriamo che sia suriettiva, ovvero che esiste almeno un elemento <span class="math-tag">\( x \in \mathbb{R}\)</span> per ogni <span class="math-tag">\( y \in \mathbb{R}\)</span>. Quindi    <span class="math-tag">\begin{aligned}         & f(x) = y         & \iff \\         & x^{4} = y         & \iff \\         & x = \pm \sqrt[4]{y}     \end{aligned}</span>     valida solo se <span class="math-tag">\( y \geq 0\)</span>.     <br ></br>     Tale funzione non è quindi suriettiva. </div><div class="myexample environment" id="example4" ><span class="myexample-header environment-title">Esempio 4 - Verificare se una funzione è suriettiva - Esempio 3</span>     Considerando la funzione     <span class="math-tag">\begin{aligned}         & f : \mathbb{R} \to \mathbb{R}         & f(x) = \frac{1}{x}     \end{aligned}</span>     dimostriamo che sia suriettiva, ovvero che esiste almeno un elemento <span class="math-tag">\( x \in \mathbb{R}\)</span> per ogni <span class="math-tag">\( y \in \mathbb{R}\)</span>. Quindi    <span class="math-tag">\begin{aligned}         & f(x) = y         & \iff \\         & \frac{1}{x} = y         & \iff \\         & x = \frac{1}{y}     \end{aligned}</span>     valida solo se <span class="math-tag">\( y \neq 0\)</span>.      <br ></br>     Tale funzione non è quindi suriettiva. </div><div class="definition environment" id="def1-13" ><span class="definition-header environment-title">Definizione 1.13 - Funzione iniettiva</span>     Una funzione <span class="math-tag">\( f\)</span> si dice iniettiva se ogni <span class="math-tag">\( y \in im(f)\)</span> è immagine solo di un elemento <span class="math-tag">\( x \in dom(f)\)</span>, ovvero se ad ogni <span class="math-tag">\( x \in X\)</span> corrisponde un distinto elemento <span class="math-tag">\( y \in Y\)</span>.     <br ></br>     Ciò implica che se <span class="math-tag">\( x_{1}\)</span> è diverso da <span class="math-tag">\( x_{2}\)</span>, allora l'immagine di <span class="math-tag">\( x_{1}\)</span> sarà diversa dall'immagine di <span class="math-tag">\( x_{2}\)</span><span class="math-tag">\[         \forall x_{1}, x_{2} \in X         \quad         x_{1} \neq x_{2}          \qquad \implies \qquad         f(x_{1}) \neq f(x_{2})     \]</span>     che sarebbe l'equivalente a dire che se <span class="math-tag">\( x_{1} = x_{2}\)</span>, allora l'immagine di <span class="math-tag">\( x_{1}\)</span> sarà uguale all'immagine di <span class="math-tag">\( x_{2}\)</span><span class="math-tag">\[         \forall x_{1}, x_{2} \in X         \quad         x_{1} = x_{2}          \qquad \implies \qquad         f(x_{1}) = f(x_{2})     \]</span><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Are you iniettiva</span>         Per stabilire se una funzione è iniettiva si deve considerare la funzione <span class="math-tag">\( y = f(x)\)</span> ed imporre l'uguaglianza          <span class="math-tag">\[             f(x_{1}) = f(x_{2})         \]</span>         Una volta risolta l'uguaglianza, nel caso l'unica possibile soluzione sia <span class="math-tag">\( x_{1} = x_{2}\)</span> possiamo dire che la funzione è iniettiva.     </div><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Interpretazione grafica</span>         Graficamente, una funzione è iniettiva se e solo se ogni retta parallela all'asse <span class="math-tag">\( x\)</span> interseca il grafico della funzione al massimo una volta.     </div></div><div class="myexample environment" id="example5" ><span class="myexample-header environment-title">Esempio 5 - Verificare se una funzione è iniettiva - Esempio 1</span>     Considerando la funzione     <span class="math-tag">\begin{aligned}         & f : \mathbb{R} \to \mathbb{R}         & f(x) = x^{3}     \end{aligned}</span>     imponiamo l'uguaglianza     <span class="math-tag">\begin{aligned}         & f(x_{1}) = f(x_{2})          & \iff \\         & (x_{1})^{3} = (x_{3})^{2}         & \iff \\         & \sqrt[3]{(x_{1})^{3}}  =  \sqrt[3]{(x_{2})^{3}}         & \iff \\         & x_{1} = x_{2}     \end{aligned}</span>     Dato che <span class="math-tag">\( x_{1} = x_{2}\)</span>, possiamo dire che la funzione è iniettiva. </div><div class="myexample environment" id="example6" ><span class="myexample-header environment-title">Esempio 6 - Verificare se una funzione è iniettiva - Esempio 2</span>     Considerando la funzione     <span class="math-tag">\begin{aligned}         & f : \mathbb{R} \to \mathbb{R}         & f(x) = x^{2}     \end{aligned}</span>     imponiamo l'uguaglianza     <span class="math-tag">\begin{aligned}         & f(x_{1}) = f(x_{2})          & \iff \\         & (x_{1})^{2} = (x_{2})^{2}         & \iff \\         & + x_{1} = \pm x_{2}     \end{aligned}</span>     Dato che <span class="math-tag">\( x_{1} \neq -x_{2}\)</span>, possiamo dire che la funzione non è iniettiva. </div><div class="definition environment" id="def1-14" ><span class="definition-header environment-title">Definizione 1.14 - Isomorfismo tra gruppi</span>     Considerando due gruppi <span class="math-tag">\( (A, +_{A})\)</span> e <span class="math-tag">\( (B, +_{B})\)</span> e l'omomorfismo     <span class="math-tag">\[         f: A \to B     \]</span>      se <span class="math-tag">\( f\)</span> è una funzione biettiva, si dice che <span class="math-tag">\( f\)</span> è un isomorfismo.     <div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Funzione esponenziale come isomorfismo</span>         Considerando i due gruppi <span class="math-tag">\( (\mathbb{R}, +)\)</span> e <span class="math-tag">\( (\mathbb{R}^{+}, \cdot)\)</span> e la funzione "esponenziale" (<span class="math-tag">\( exp\)</span>)         <span class="math-tag">\[             exp: \mathbb{R} \to \mathbb{R}^{+}          \]</span>         si ha che         <span class="math-tag">\[             e^{x + y} = e^{x} \cdot e^{y}         \]</span>         La funzione <span class="math-tag">\( exp\)</span> è quindi un isomorfismo.     </div><div class="mynote environment" ><span class="mynote-header environment-title">Osservazioni personali - Siamo poi così diversi, io e te?</span>         Quando si ha un isomorfismo, in realtà i due gruppi sono "lo stesso camuffato".      </div></div><div class="definition environment" id="def1-15" ><span class="definition-header environment-title">Definizione 1.15 - Generalizzazione di omomorfismo e isomorfismo</span>     Considerando due strutture algebriche <span class="math-tag">\( (A, +_{A}, \cdot_{A}, \ \ldots \ , *_{A})\)</span> e <span class="math-tag">\( (B, +_{B}, \cdot_{B}, \ \ldots \ , *_{B})\)</span>, la funzione     <span class="math-tag">\[         f: A \to B     \]</span>     è un omomorfismo se si ha che, considerando <span class="math-tag">\( a, b \in A\)</span><span class="math-tag">\begin{aligned}         & f(a +_{A} b) = f(a) +_{B} f(b)         \\         & f(a \cdot_{A} b) = f(a) \cdot_{B} f(b)         \\         & \vdots         \\         & f(a *_{A} b) = f(a) *_{B} f(b)     \end{aligned}</span>     Nel caso <span class="math-tag">\( f\)</span> sia una funzione biettiva, si dice che <span class="math-tag">\( f\)</span> è un isomorfismo. </div><div class="demonstration environment" id="dem1-4" ><span class="demonstration-header environment-title">Dimostrazione 1.4 - Esistenza di un omomorfismo tra gruppi e commutatività di un gruppo come condizione sufficiente per la commutatività dell'altro</span>     Data la proposizione     <div class="proposition environment" ><span class="proposition-header environment-title">Enunciato</span>         Considerando due gruppi <span class="math-tag">\( (A, +_{A})\)</span> e <span class="math-tag">\( (B, +_{B})\)</span> e un omorfismo tra gruppi          <span class="math-tag">\[             f: A \to B         \]</span>         se il primo gruppo è commutativo, allora anche il secondo lo è.     </div><div class="proof environment" ><span class="proof-header environment-title">Dimostrazione:<span class="material-symbols-outlined body-visibility-icon" onclick="set_proof_state(event)">visibility_off</span></span><div class="proof-body hyde">         Considerando gli elementi <span class="math-tag">\( a_{1}, a_{2} \in A\)</span> e gli elementi <span class="math-tag">\( b_{1}, b_{2} \in B\)</span>, ipotizziamo che il gruppo <span class="math-tag">\( (A, +_{A})\)</span> sia commutativo, quindi si può scrivere         <span class="math-tag">\begin{aligned}             & f(a_{1} +_{A} a_{2}) = f(a_{2} +_{A} a_{1})             & \iff         \end{aligned}</span>         e applicando la definizione di omomorfismo         <span class="math-tag">\begin{aligned}             & b_{1} +_{B} b_{2} = b_{2} +_{B} b_{1}             &          \end{aligned}</span>         che è esattamente la definizione di gruppo commutativo: si è quindi dimostrata la proposizione.     </div></div></div></div></div>
        </div>
    </div>
    <footer class="footer-container">
        <span>
            Created by 
            <typewriting-text class="credits-subtitle" still-time="1000" erasing-speed="150" >
                <word>lorenzoarlo</word>
                <word>Lorenzo Arlotti</word>
            </typewriting-text>
        </span>
    </footer>
</body>

</html>